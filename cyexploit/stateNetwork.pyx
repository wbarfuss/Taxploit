import numpy as np
cimport numpy as np
from cpython cimport bool

from libc.math cimport exp, tanh
from regulate cimport state_Exploit

INTTYPE = np.int
FLOATTYPE = np.float
ctypedef np.int_t INTTYPE_t
ctypedef np.float_t FLOATTYPE_t


cdef extern from "stdlib.h":
    double drand48()



cdef class state(state_Exploit):


    cdef: 
        double taxation_factor 




    def __init__(self,
                 adjacency_matrix,
                 strategies,
                 #stocks,
                 rationalities,
                 taxation_factor,
                 rewiring_prob,
                 update_timescale,
                 N_agents,
                 N_states):

        super(state,self).__init__(adjacency_matrix, 
                                    strategies,
                                    #stocks,
                                    rationalities,
                                    #taxation_factor, 
                                    rewiring_prob,
                                    update_timescale,
                                    N_agents,
                                    N_states,
                                    'state_network')








      
        self.time = 0
        self._check_for_consensus()

        self.taxation_factor = taxation_factor


    '''
    def get_stateID_of_agents(self):

        """
        Return an array with the state ID an agent belongs to
        """
        cdef:
            np.ndarray a_stateID 
            counter 
            stateID 

        a_stateID = np.empty(sum(self.a_num_agents))
        counter = 0
        stateID = 0 

        ##This should be reimplemented; Very ugly
        for agentsPerState in a_num_agents:
            stateID += 1
            for i in range(agentsPerState):
                a_stateID[counter]= state_ID
                counter += 1  
    
        return a_stateID
    '''

    def create_taxation_vec(self):

        """
        Return an array of N_agents size that carries the individual taxation factor
        -------------
        For simplification there are only two different ones: taxation or no taxation

        """
        cdef:
            np.ndarray[INTTYPE_t, ndim = 1 ] stateID
            np.ndarray[FLOATTYPE_t,ndim =1 ] taxVec
            np.ndarray[INTTYPE_t,ndim =1 ] strategies
            double taxation_factor = self.taxation_factor

        stateID = self.a_stateID
        taxVec = np.empty(self.N_agents)
        strategies = self.a_Strategy

        for i in range(self.N_agents):
            taxVec[i] = taxation_factor * strategies[stateID[i]] + (1-strategies[stateID[i]])


        self.a_taxation = taxVec 
        return self.a_taxation

    def set_states_stocks(self,  agentStocks):

        """
        Cummunicate the agents stocks to their beloning states
        """

        cdef:
            np.ndarray state_ID
            np.ndarray state_Stocks
            int N_agents, N_states
        

        N_agents = self.N_agents
        N_states = self.N_states

        state_ID = self.a_stateID

        state_Stocks = np.empty(N_states)

        strategies = self.a_Strategy

        for i in range(N_agents):
            state_Stocks[state_ID[i]] += agentStocks[i]* 0.5 * (3-2*strategies[state_ID[i]])
        
        self.a_Stock = state_Stocks




    def update_system(self):

        cdef:
            int agent, neighb
            double update_time
            np.ndarray[INTTYPE_t, ndim=1] neighbors


        #agent, neighb, neighbors, update_time 
        [agent, neighb, neighbors, update_time ]  = self._update_candiadates()
        #print buffer_list
        #= buffer_list
        if agent == -1: return -1    # no update canditates found (BAD)
        
        if self.get_consensus():
            #print 'state get_consensus reached'
            return update_time
        self._perform_social_update(agent, neighb, neighbors)


        return update_time



    cdef void _perform_social_update(
        self, int agent, int neighb, np.ndarray[INTTYPE_t, ndim = 1] neighbors):
        """
        Perform a social update.

        Parameters
        ----------
        agent : int
            The index of the current update agent
        neighb : int
            The index of its update neighbor
        neighbors : np.array of type int
            All of the neighbors of the update agent
        """
        cdef:
            int j, new_nb
            double dH, rewiring_prob=self.rewiring_prob
            np.ndarray[INTTYPE_t, ndim=1] same_unconnected =\
                np.zeros(self.N_states, dtype=int)
            np.ndarray[INTTYPE_t, ndim=1] S = self.a_Strategy
            np.ndarray[INTTYPE_t, ndim=2] A = self.adjacency_matrix

        if (rewiring_prob == 1 or
            (rewiring_prob != 0 and
             drand48() < rewiring_prob)):
            # rewire
            for j in xrange(self.N_states):
                if (S[j] == S[agent] and j not in neighbors and j != agent):
                    same_unconnected[j] = 1
            same_unconnected = same_unconnected.nonzero()[0]
            if len(same_unconnected) > 0:
                new_nb = np.random.choice(same_unconnected)
                A[agent, neighb] = A[neighb, agent] = 0
                A[agent, new_nb] = A[new_nb, agent] = 1

        else:
            # switch effort
            dH = self.a_Stock[neighb] - self.a_Stock[agent]

            #dH =  harvests[neighb] * ((1-(1-a_Strategy[neighb]) * self.a_taxation[agent]) \
            #   - harvests[agent]  * ((1-(1-a_Strategy[agent ]) * self.a_taxation[agent])

            if drand48() < 0.5 * (tanh(self.a_Rationality[agent]*dH) + 1):
                self.a_Strategy[agent] = self.a_Strategy[neighb]

        
