import numpy as np
cimport numpy as np
from cpython cimport bool
from scipy.sparse.csgraph import connected_components

'''
INTTYPE = np.int
FLOATTYPE = np.float
ctypedef np.int_t INTTYPE_t
ctypedef np.float_t FLOATTYPE_t
'''


cdef class state_Exploit(object):
    
    """
    cdef:
        np.ndarray adjacency_matrix
        
        unsigned int N_agents
        unsigned int N_states

        np.ndarray a_Stock

        np.ndarray a_taxation   #the taxrate the harvest gets reduced by

        np.ndarray a_Strategy

        np.ndarray a_Rationality
        np.ndarray a_UpdateTime

        np.ndarray a_state_ID


        double rewiring_prob
        double update_timescale

        double time
        bool consensus

        unsigned int step


        np.ndarray[INTTYPE_t, ndim=2]
np.ndarray[INTTYPE_t, ndim=1]
np.ndarray[FLOATTYPE_t, ndim=1]
np.ndarray[FLOATTYPE_t, ndim=1]
np.ndarray[FLOATTYPE_t, ndim=1]
np.ndarray[FLOATTYPE_t, ndim=1]




    """


    def __init__(self,
                  adjacency_matrix,
                  strategies,
                  #stocks,
                  rationalities,
                  #taxations,
                  rewiring_prob,
                  update_timescale,
                  N_agents,
                  N_states,
                  network_type):

        self.adjacency_matrix = adjacency_matrix
        self.a_Strategy  = strategies
        #self.a_Stock = stocks
        self.a_Rationality = rationalities
        #self.a_taxation = taxations
        self.rewiring_prob = rewiring_prob
        #print 'inside regulate.pyx',type(update_timescale),update_timescale
        self.update_timescale = update_timescale



        self.a_UpdateTime =\
            np.random.exponential(self.update_timescale, self.adjacency_matrix.shape[0])        

        self.time = 0
        self._check_for_consensus()

        self.N_agents = N_agents
        self.N_states = N_states

        self.network_type =network_type

    cpdef get_consensus(self):
        """
        Return the True if the model is in the consensus state,
        otherwise False
        """
        return self.consensus

    cpdef get_adjacency(self):
        """
        Return the current adjacency matrix.
        """
        return self.adjacency_matrix

    cpdef get_strategies(self):
        """
        Return the current strategies of the agents.
        """
        return self.a_Strategy

    cpdef get_stocks(self):
        """
        Return the current stocks of the agents.
        """
        return self.a_Stock

    cpdef get_time(self):
        """
        Return the current model time.
        """
        return self.time

    cpdef get_timeVector(self):
        """
        Return the complete time vector.
        """
        return self.a_UpdateTime


    cpdef get_time_min(self):
        """
        Return the minimum of the time vector
        """
        return np.min(self.a_UpdateTime)


    cpdef set_stock(self,np.ndarray[FLOATTYPE_t, ndim = 1] stock):
        self.a_Stock = stock

        
    cpdef get_step(self):
        return self.step


    cpdef set_stateID(self,np.ndarray[INTTYPE_t, ndim = 1] a_stateID):
        self.a_stateID = a_stateID

    cpdef get_stateID(self):
        return self.a_stateID

    cdef _check_for_consensus(self):
        """
        Check for consensus.

        Returns
        -------
        consensus : bool
            True if model is into consensus state, otherwise False
        """
        cc = connected_components(self.adjacency_matrix, directed=False)[1]
        self.consensus = all(len(np.unique(self.a_Strategy[c])) == 1
                             for c in ((cc == i).nonzero()[0]
                             for i in np.unique(cc)))

        return self.consensus
   
    cpdef check_for_consensus(self):
        consensus = self._check_for_consensus()
        return consensus


    cdef _update_candiadates(self):
        """
        Find an agent and one of its neighbors that are suitable for an update.

        Returns
        -------
        object : (agent, neighbor, neighbors, update_time)
            agent : int
                the index number of the update agent OR -1 if no update
                candidates could be found and no consensus is detected
            neighbor : int
                the index of one of its neighbors
            neighbors : np.array of type int
                all neighbors of agent (needed for the social update)
            update_time : double
                the model time of the update (needed for the stock integration)
        """
        cdef:
            int Nn = self.adjacency_matrix.shape[0]
            int i, agent, neighb=Nn, N = Nn
                # neighb == N means update candidate not found
            double update_time=0.0, update_timescale = self.update_timescale
        



        a_UpdateTime = self.a_UpdateTime
        a_Strategy = self.a_Strategy
        adj_mat = self.adjacency_matrix
            


        '''neighbors
        '''   

        '''
        np.ndarray[FLOATTYPE_t, ndim=1]
        np.ndarray[INTTYPE_t, ndim=1]
        np.ndarray[INTTYPE_t, ndim=2]
        np.ndarray[INTTYPE_t, ndim=1]
        '''


        # Needs to return alwas an int, int, np.ndarray, double
        i = 0
        while i < 100*N:
            agent = a_UpdateTime.argmin()
            update_time = a_UpdateTime[agent]
            a_UpdateTime[agent] += np.random.exponential(update_timescale)
            neighbors = adj_mat[agent].nonzero()[0]

            if len(neighbors) > 0:
                neighb = np.random.choice(neighbors)
                if (a_Strategy[neighb] == a_Strategy[agent]):
                    #Update candidates NOT found
                    neighb = N

            if neighb < N:  # Update candidates found
                break
            else:  # No neighb found
                i += 1
                if i >= N:  # more than N agents wer unsuitable
                    if self._check_for_consensus():
                        # return because of consensus
                        break
        if i >= 100*N:  # no update candidates found and no consensus
            agent = -1
        #print 'test',   agent, neighb, neighbors, update_time
        return [agent, neighb, neighbors, update_time]



    '''
    cdef void _perform_social_update(
        self, int agent, int neighb, np.ndarray[INTTYPE_t, ndim = 1] neighbors,
        np.ndarray[FLOATTYPE_t, ndim = 1] harvests):
        """
        Perform a social update.

        Parameters
        ----------
        agent : int
            The index of the current update agent
        neighb : int
            The index of its update neighbor
        neighbors : np.array of type int
            All of the neighbors of the update agent
        harvests : np.array[N] of type float
            The current harvest of all the agents
        """
        cdef:
            int j, new_nb
            double dH, rewiring_prob=self.rewiring_prob
            np.ndarray[INTTYPE_t, ndim=1] same_unconnected =\
                np.zeros(self.N, dtype=int)
            np.ndarray[INTTYPE_t, ndim=1] S = self.a_Strategy
            np.ndarray[INTTYPE_t, ndim=2] A = self.adjacency_matrix

        if (rewiring_prob == 1 or
            (rewiring_prob != 0 and
             drand48() < rewiring_prob)):
            # rewire
            for j in xrange(self.N):
                if (S[j] == S[agent] and j not in neighbors and j != agent):
                    same_unconnected[j] = 1
            same_unconnected = same_unconnected.nonzero()[0]
            if len(same_unconnected) > 0:
                new_nb = np.random.choice(same_unconnected)
                A[agent, neighb] = A[neighb, agent] = 0
                A[agent, new_nb] = A[new_nb, agent] = 1

        else:
            # switch effort
            #dH = harvests[neighb] - harvests[agent]

            dH =  harvests[neighb] * ((1-(1-a_Strategy[neighb]) * self.a_taxation[agent]) \
                - harvests[agent]  * ((1-(1-a_Strategy[agent ]) * self.a_taxation[agent])

            if drand48() < 0.5 * (tanh(self.a_Rationality[agent]*dH) + 1):
                self.a_Strategy[agent] = self.a_Strategy[neighb]
    '''


    
    cpdef print_parameter(self,str filename):
        
        if not filename.endswith('.txt'):
            filename = filename + '.txt'
        
        with open(filename,'a') as f:
            f.write('#network_type '+ self.network_type)
            f.write('time '+ str(self.time)+ '\n')
            f.write('step '+ str(self.step)+ '\n')
            f.write('consensus '+ str(self.consensus)+ '\n')
            f.write('N_user '+ str(self.N_agents)+ '\n')
            f.write('N_states '+ str(self.N_states)+ '\n')
            f.write('rewiring_prob '+ str(self.rewiring_prob)+ '\n')
            f.write('update_timescale '+ str(self.update_timescale)+ '\n')
            f.write('#Derived Quantities \n')
            try:
                f.write('taxation_factor '+str(self.a_taxation[self.a_taxation.nonzero()[0][0]])+ '\n')
            except:
                f.write('taxation_factor 0'+ '\n')
                f.write('#taxation_factor 0 can also mean that there are no agents getting taxed'+ '\n')
            try:
                f.write('mean_stock '+ str(np.mean(self.a_Stock))+ '\n')
            except:
                f.write('#stock not defined at the moment\n')
            f.write('sus_share '+ str(np.mean(self.a_Strategy))+ '\n')
            f.write('\n')
            
    

        



